# 1. Service Registry
Шаблон предоставляет центральный репозиторий для обнаружения микрослужб по имени. Это шаблон архитектуры микрослужб, который позволяет службам обнаруживать другие микрослужбы и взаимодействовать друг с другом.

В этом шаблоне центральный реестр или каталог служб используется для хранения записей о доступных службах и их расположении. Микросервисы могут регистрироваться в реестре, а другие микросервисы могут искать в реестре местонахождение необходимых сервисов.

Например, предположим, что у нас есть большой веб-сайт электронной коммерции, который состоит из множества микросервисов , таких как служба заказа, служба оплаты, служба доставки и служба поддержки клиентов. Каждая из этих служб имеет собственный REST API, который другие службы могут использовать для связи с ней.

Чтобы упростить обнаружение этими службами друг друга, мы можем использовать шаблон реестра служб . Мы можем настроить реестр сервисов, таких как Consul или Eureka (предоставляется в облаке Spring), в котором хранится список всех доступных сервисов и их конечных точек.

Когда служба запускается, она может зарегистрироваться в реестре, указав свое имя и конечную точку.

Например, служба заказов может зарегистрировать себя как «служба заказов» с конечной точкой « http://order-service:8080 ». Другие службы, которым необходимо взаимодействовать со службой заказов, могут затем найти ее конечную точку в реестре, используя ее имя.

Например , платежная служба может найти конечную точку «служба заказа» в реестре, чтобы отправить платежную информацию службе заказов. Точно так же служба доставки может искать конечную точку «служба заказа» в реестре, чтобы получить информацию о доставке заказа.

Таким образом, каждую службу можно разрабатывать и развертывать независимо, без жесткого кодирования конечных точек других служб в ее коде. Шаблон реестра служб позволяет службам динамически находить друг друга, делая систему более гибкой и устойчивой к изменениям.

# 2.	Circuit Breaker (Схема автоматического выключателя)

Как следует из названия, шаблон прерывателя цепи предотвращает каскадный сбой, разрывая цепь, и позволяет приложениям продолжать работу при сбое одной или нескольких служб . Он используется для обработки ошибок, которые могут возникнуть в микросервисной архитектуре.

В этом шаблоне прерыватель цепи действует как сеть безопасности между клиентом и службой, защищая клиента от сбоев в службе. Прерыватель цепи отслеживает состояние службы и, если он обнаруживает, что служба дает сбой, он может разомкнуть цепь и предотвратить отправку дальнейших запросов в службу до тех пор, пока служба не будет восстановлена.

Например, предположим, что приложение микрослужбы использует ненадежную внешнюю службу, и приложению необходимо продолжать работу даже в случае сбоя внешней службы.

В этом сценарии можно использовать шаблон прерывателя цепи, чтобы определить, когда внешняя служба недоступна , и переключиться на альтернативную службу или резервную службу, пока внешняя служба снова не станет доступной.


В микросервисной архитектуре шаблон прерывателя цепи может быть реализован с помощью таких инструментов, как Hystrix от Netflix или Spring Cloud Circuit Breaker, которые позволяют управлять поведением прерывателя цепи и позволяют приложению контролируемым образом реагировать на сбои службы.

# 3.	API Gateway

Шаблон шлюза API — это еще один распространенный шаблон проектирования, используемый в архитектуре микросервисов, который включает шлюз API, выступающий в качестве точки входа для всех входящих запросов API. Он обеспечивает единую точку входа для всех микрослужб и действует как прокси-сервер между клиентами и микрослужбами, направляя запросы соответствующей службе.

Основная цель шлюза API — отделить клиентов от микросервисов, абстрагируя сложность системы за упрощенным и согласованным API. Это также означает, что вам не нужно находить и запоминать адреса более чем 100 API-интерфейсов REST Microservice.

Он также обеспечивает дополнительный уровень безопасности и управления, позволяя организациям контролировать и управлять доступом к своим службам, отслеживать производительность системы и применять политики для всех служб.

Вот пример того, как шаблон шлюза API работает в простой системе электронной коммерции:

Предположим, что система электронной коммерции имеет несколько микросервисов для выполнения различных функций, таких как управление заказами, каталог продуктов и аутентификация пользователей. У каждой микрослужбы есть собственная конечная точка API для обработки запросов. Однако клиенту, которым может быть веб-приложение или мобильное приложение, необходимо получить доступ ко всем этим микросервисам через единую точку входа.

Здесь в игру вступает шлюз API. Шлюз API действует как обратный прокси-сервер, который получает все входящие запросы от клиентов. Затем он направляет каждый запрос в соответствующую микрослужбу в зависимости от запрошенной конечной точки.

Например, шлюз API может направлять запросы к /orders конечной точке в микрослужбу управления заказами, а запросы к /products конечной точке — в микрослужбу каталога продуктов.


Шлюз API также может выполнять дополнительные функции, такие как преобразование запросов и ответов, ограничение скорости, аутентификация и авторизация, а также кэширование.

Он также может предоставить унифицированный API, который скрывает внутренние детали микросервисов и предоставляет клиентам более простой и согласованный интерфейс.

В целом шаблон шлюза API обеспечивает масштабируемый, гибкий и безопасный способ управления микросервисами в сложной системе, упрощая разработку, развертывание и обслуживание приложений на основе микросервисов.

# 4. Saga Pattern

Шаблон Saga предоставляет способ управления транзакциями, включающими несколько микросервисов. Он используется для обеспечения успешного завершения серии транзакций в нескольких службах, а если нет, для отката или отмены всех изменений, которые были сделаны до этого момента.

Шаблон Saga состоит из последовательности локальных транзакций, каждая из которых обновляет состояние отдельной службы , и соответствующего набора компенсирующих транзакций, которые используются для отмены эффектов исходных транзакций в случае сбоя.

Вот пример того, как шаблон Saga используется в приложении электронной коммерции на основе микросервиса:

Предположим, у вас есть два микросервиса, один из которых отвечает за обработку заказов, а другой — за доставку заказов .

Когда размещается новый заказ, служба обработки заказов отвечает за проверку заказа и обеспечение наличия товаров на складе, а служба доставки отвечает за упаковку заказа и отправку его покупателю.

Если служба обработки заказов определяет, что заказ действителен и все товары есть в наличии, она отправляет сообщение в службу доставки, чтобы инициировать процесс доставки. В этот момент в игру вступает шаблон Saga.

Служба доставки создаст новую транзакцию для упаковки и отправки заказа, и, если транзакция пройдет успешно, она пометит заказ как отправленный.

С другой стороны, если транзакция завершится неудачно (возможно, из-за проблемы с поставщиком услуг доставки), служба доставки инициирует компенсирующую транзакцию, чтобы отменить последствия исходной транзакции, такие как отмена отправки и пополнение запасов товаров.


Тем временем служба обработки заказов также использует шаблон Saga для управления собственной транзакцией . Если служба доставки сообщит об успешной отправке заказа, служба обработки заказов пометит заказ как выполненный.

Если служба доставки сообщает об ошибке, служба обработки заказов инициирует компенсационную транзакцию для отмены заказа и возврата всех уплаченных средств.

В целом, шаблон Saga обеспечивает способ управления сложными транзакциями в нескольких микросервисах таким образом, чтобы обеспечить согласованность и надежность. Если вам нужно выучить только один шаблон, вам лучше изучить шаблоны SAGA, поскольку они чрезвычайно полезны в приложениях Microservice.


# 5.	Event-Driven Architecture

Event Sourcing — это шаблон микросервиса, используемый для сохранения и запроса данных в приложении. Вместо сохранения текущего состояния объекта Event Sourcing сохраняет все события, происходящие в приложении, позволяя реконструировать состояние объекта в любой момент времени.

В этом шаблоне каждое изменение состояния в приложении регистрируется как событие и сохраняется в виде журнала событий. Состояние приложения можно восстановить, воспроизведя эти события. Это означает, что Event Sourcing обеспечивает журнал аудита всех изменений, происходящих в приложении.

Например, рассмотрим приложение электронной коммерции. Когда пользователь размещает заказ, OrderPlaced событие генерируется и сохраняется в журнале. Когда заказ отгружен, ShipmentMade событие генерируется и сохраняется в журнале.

Если заказ отменен, OrderCanceled событие генерируется и сохраняется в журнале. Воспроизводя события, можно определить текущее состояние заказа.
![Image alt](https://miro.medium.com/v2/resize:fit:828/format:webp/0*s58D4hu5wqDDxPw6.png)
Event Sourcing имеет ряд преимуществ:

Возможность аудита : все изменения в системе могут быть проверены и отслежены до их источника.
Масштабируемость : события могут обрабатываться параллельно, что обеспечивает лучшую масштабируемость.
Гибкость : поскольку события являются источником истины, можно изменить способ запроса и сохранения данных без изменения самих данных.
Отказоустойчивость : Поскольку события неизменяемы, их нельзя изменить, что гарантирует, что данные всегда верны .
Однако внедрение Event Sourcing может быть сложным и требует тщательного планирования. Кроме того, запрос данных может выполняться медленнее, поскольку он требует повторного воспроизведения всех событий, поэтому перед использованием убедитесь, что они вам действительно нужны. Чаще всего будет альтернативное решение.



# 6.	Command Query Responsibility Segregation

Шаблон Command Query Responsibility Segregation (CQRS) — это еще один популярный шаблон проектирования Microservice, который разделяет команды (операции записи) и запросы (операции чтения) на отдельные модели, каждая из которых имеет собственную базу данных.

Шаблон основан на идее, что модели, используемые для записи данных, не совпадают с моделями, используемыми для чтения данных.

В этом шаблоне командная модель получает команды от клиента и записывает их в базу данных. Модель запроса считывает данные из базы данных и отправляет данные клиенту. Шаблон можно использовать для повышения производительности и масштабируемости системы, поскольку каждую модель можно оптимизировать для своей конкретной задачи.

Например, рассмотрим приложение электронной коммерции, которое использует традиционный подход на основе CRUD для управления информацией о продуктах. Одна и та же модель и база данных используются как для чтения, так и для записи информации о продукте. По мере роста приложения модель становится все более сложной, а база данных становится узким местом производительности.

При использовании CQRS приложение будет иметь отдельную модель команд для записи информации о продукте и отдельную модель запроса для чтения информации о продукте. Модель команд будет оптимизирована для быстрой записи, а модель запросов будет оптимизирована для быстрого чтения.

Командная модель будет хранить данные в базе данных, оптимизированной для записи, а модель запроса будет хранить данные в базе данных, оптимизированной для чтения. Две модели будут обмениваться данными через шину событий или очередь сообщений.

![Image alt](https://miro.medium.com/v2/resize:fit:828/format:webp/0*XXihSTI8eujdDXcb.png)

В целом, CQRS может улучшить масштабируемость и производительность системы, а также упростить кодовую базу за счет разделения задач. Однако это также может добавить сложности и потребовать дополнительных усилий по разработке, поскольку требуются отдельные модели и базы данных.





# 7.	Event Sourcing Pattern

Шаблон проектирования перегородки — это способ изоляции различных частей системы, чтобы сбой в одной части не влиял на остальную часть системы. В архитектуре микросервисов шаблон перегородки можно использовать для изоляции различных микросервисов, чтобы сбой в одном микросервисе не приводил к останову всей системы.

Это очень похоже на шаблон прерывателя цепи, который также предотвращает каскадный сбой, но вместо разрыва цепи этот шаблон проектирования фокусируется на изоляции и самодостаточных микрослужбах, как показано на диаграмме ниже, чем служба A имеет свой собственный пул соединений, который не используется совместно службой B и Служба С.

![Image alt](https://miro.medium.com/v2/resize:fit:828/format:webp/0*lJWUruzPPVPb8Qos.png)



# 8.	Backends for Frontends (BFF)

Backends for Frontends (BFF) — это шаблон проектирования, используемый в архитектуре микросервисов для обработки сложного взаимодействия клиент-сервер в контексте нескольких пользовательских интерфейсов. Он предлагает иметь отдельную внутреннюю службу для каждого внешнего интерфейса для удовлетворения конкретных потребностей этого интерфейса.

Это позволяет разработчикам оптимизировать поток данных, механизмы кэширования и аутентификации для уникальных потребностей внешнего интерфейса, сохраняя при этом модульность и развязку внутренних служб.

Например, предположим, что у вас есть веб-приложение и мобильное приложение, которым требуется доступ к одному и тому же набору служб. В этом случае вы можете создать отдельные серверные службы для каждого приложения, оптимизированные для конкретной платформы.

Серверная часть веб-приложения может обрабатывать большие объемы данных для более быстрой загрузки, в то время как серверная часть мобильного приложения может оптимизироваться для уменьшения задержки и использования сети.

![Image alt](https://miro.medium.com/v2/resize:fit:828/format:webp/0*We_BgxW37j_ck988.png)

Этот шаблон позволяет командам оптимизировать взаимодействие с пользователем для каждого интерфейса, используя отдельные серверные службы для каждого из них. Это также позволяет им избежать использования одной серверной службы, которая должна обслуживать множество различных интерфейсов с различными потребностями, что может стать все более сложным и трудным в обслуживании.


Краткое содержание
Вау, это долго писать и читать, но теперь, когда мы узнали основные сведения об основных шаблонах проектирования микросервисов, пришло время обобщить их одним словом, чтобы вы легко их запомнили и решили, когда их использовать.

Вот некоторые популярные шаблоны проектирования микросервисов, которые должен знать программист:

Шаблон Service Registry предоставляет центральное место для регистрации служб.
Автоматический выключатель позволяет вашим службам быстро выходить из строя и предотвращает каскадные сбои . Шаблон прерывателя цепи используется для изоляции неисправной службы.
Шлюз API предоставляет общую точку входа для всех запросов и ответов системы. Таким образом, клиент запоминает только один адрес хоста/порта, а не несколько IP-адресов для каждой микрослужбы.
Архитектура, управляемая событиями, позволяет службам взаимодействовать друг с другом, отправляя события.
В базе данных на службу каждая служба имеет свою собственную базу данных , что позволяет службам работать независимо.
Разделение ответственности за запросы команд ( CQRS ) разделяет запросы на чтение и запись для приложения , обеспечивая лучшее масштабирование и производительность.
Внешняя конфигурация позволяет хранить данные конфигурации вне кода приложения , что упрощает управление изменениями конфигурации.
Saga Pattern управляет транзакцией для длительных транзакций , охватывающих несколько служб.
Bulkhead Pattern изолирует сбои внутри микросервиса, поэтому один сбой не приводит к остановке всей системы.
Шаблон проектирования Backends for Frontends (BFF) предоставляет конкретную серверную часть для каждого клиента. Это позволяет фронтенд-команде быстро разрабатывать функции и добавлять новые клиентские функции.
И, если вы хотите узнать больше, есть хорошая книга под названием Microservices Patterns Криса Ричардсона, которую определенно стоит прочитать Java-разработчикам.








