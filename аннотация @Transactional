#  аннотация @Transactional

Аннотация @Transactional— это мощный инструмент, упрощающий управление транзакциями базы данных за счет автоматизации границ транзакций. Это позволяет разработчикам сосредоточиться на бизнес-логике, обеспечивая при этом целостность и согласованность (ACID) операций с данными.


Изображение взято с https://blog.ippon.tech/
@TransactionalВ этом сообщении блога мы подробно рассмотрим аннотацию , включая ее внутренности, функции и более глубокое изучение изоляции и распространения. Для начала рассмотрим пример, демонстрирующий @Transactionalиспользование аннотации.

@Transactional 
public  void  processBatchData (список записей <DataRecord>) { 
    for (запись DataRecord: записи) { 
        processRecord (запись); 
    } 
} 

private  void  processRecord (запись DataRecord) { 
    // Обработать и обновить запись в базе данных 
    // ...
 }
Приведенный выше пример пытается выполнить пакетную операцию. Пакетная обработка часто включает в себя выполнение ряда операций с базой данных над большим набором данных. Аннотацию @Transactionalможно использовать, чтобы гарантировать, что все операции обрабатываются атомарно, сохраняя согласованность данных. Когда @Transactionalаннотация применяется к методу или классу, это обычно означает, что транзакция должна быть инициирована до того, как метод начнет выполняться, и зафиксирована или отменена после завершения метода.

Так что же именно происходит, когда вы используете аннотацию @Transactional? —

При использовании @Transactionalаннотации платформа создает прокси вокруг целевого класса или метода. Этот прокси перехватывает вызовы методов и добавляет транзакционное поведение. Этот механизм позволяет платформе динамически управлять транзакционными аспектами аннотированных методов.
Прокси перехватывает вызовы методов и применяет транзакционный аспект к аннотированным методам. Этот аспект состоит из предтранзакционного, посттранзакционного кода и кода обработки исключений, который управляет жизненным циклом транзакции.
Аннотация @Transactionalвзаимодействует с диспетчером транзакций, который отвечает за создание, фиксацию и откат транзакций. Менеджер транзакций координирует свои действия с базовой базой данных или ресурсом, чтобы гарантировать атомарное выполнение транзакционных операций.
Аннотация @Transactionalопределяет границы, в которых метод работает как одна транзакция. Когда вызывается метод, аннотированный с помощью @Transactional, транзакционный аспект перехватывает вызов метода и запускает новую транзакцию или присоединяется к существующей на основе указанного поведения распространения.
Какие функции предоставляет аннотация @Transactional? —

Вы можете указать уровень изоляции для транзакции: Атрибут isolationаннотации @Transactionalопределяет уровень изоляции для транзакции. Уровни изоляции определяют, как транзакция взаимодействует с параллельными транзакциями и как она сохраняет целостность данных.

Вот наиболее часто используемые уровни изоляции при обработке транзакций и их пояснения:

DEFAULT(Уровень изоляции базовой базы данных по умолчанию): DEFAULTУровень изоляции указывает, что следует использовать уровень изоляции базовой базы данных по умолчанию. Фактический уровень изоляции по умолчанию зависит от используемой системы баз данных.
@Transactional(isolation = Isolation.DEFAULT) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод помечен значком @Transactional(isolation = Isolation.DEFAULT), указывающим, что для транзакции следует использовать уровень изоляции базовой базы данных по умолчанию.

2. READ_UNCOMMITTED: READ_UNCOMMITTEDуровень изоляции разрешает грязное чтение, то есть транзакция может считывать незафиксированные данные из другой транзакции, которая еще не была зафиксирована. Этот уровень изоляции обеспечивает наименьшую целостность данных.

@Transactional(isolation = Isolation.READ_UNCOMMITTED) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод помечен значком @Transactional(isolation = Isolation.READ_UNCOMMITTED), что позволяет транзакции считывать незафиксированные данные из других параллельных транзакций.

3. Уровень READ_COMMITTEDизоляции READ_COMMITTEDгарантирует, что транзакция может считывать только те данные, которые были зафиксированы другими транзакциями. Он предотвращает грязное чтение, но допускает неповторяющееся чтение и фантомное чтение.

@Transactional(isolation = Isolation.READ_COMMITTED) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод снабжен аннотацией @Transactional(isolation = Isolation.READ_COMMITTED), что гарантирует, что транзакция считывает только зафиксированные данные из других транзакций.

4. Уровень REPEATABLE_READизоляции REPEATABLE_READгарантирует, что транзакция может последовательно считывать одни и те же данные на протяжении всей своей жизни. Он предотвращает грязное и неповторяемое чтение, но допускает фантомное чтение.

@Transactional(isolation = Isolation.REPEATABLE_READ) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод снабжен аннотацией @Transactional(isolation = Isolation.REPEATABLE_READ), гарантирующей, что транзакция будет получать непротиворечивые данные на протяжении всего своего выполнения.

5. SERIALIZABLE: SERIALIZABLEУровень изоляции обеспечивает наивысший уровень целостности данных. Это гарантирует, что параллельные транзакции выполняются так, как если бы они выполнялись последовательно, избегая грязных чтений, неповторяющихся чтений и фантомных чтений.

@Transactional(isolation = Isolation.SERIALIZABLE) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод помечен значком @Transactional(isolation = Isolation.SERIALIZABLE), что обеспечивает высочайший уровень целостности данных за счет выполнения транзакции, как если бы она выполнялась последовательно.

Если вы не укажете уровень изоляции, по умолчанию будет использоваться уровень изоляции базовой базы данных по умолчанию. В PostgreSQL уровень изоляции по умолчанию — READ COMMITTED. READ COMMITTEDЭто означает, что каждая транзакция в PostgreSQL по умолчанию работает с уровнем изоляции. При использовании @Transactionalаннотации без указания isolationатрибута инфраструктура управления транзакциями будет использовать уровень изоляции базовой базы данных по умолчанию, которым в случае PostgreSQL является READ COMMITTED.

Вы можете указать тайм-аут для транзакции: Атрибут timeoutаннотации @Transactionalуказывает максимальное время, разрешенное для выполнения транзакции, прежде чем она истечет и откатится. Значение тайм-аута указано в секундах.

@Transactional(timeout = 60) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод помечен значком @Transactional(timeout = 60), указывающим, что транзакция должна быть завершена по тайм-ауту и ​​отменена, если ее выполнение занимает более 60 секунд.

Вы можете пометить транзакцию как доступную только для чтения: атрибут readOnlyаннотации @Transactionalопределяет, является ли транзакция доступной только для чтения или для чтения и записи. В режиме только для чтения транзакции не разрешается изменять какие-либо данные, что обеспечивает потенциальную оптимизацию производительности.

@Transactional (readOnly = true ) 
public  void  PerformReadOperation ( ) { 
    // Операция только для чтения 
    // ...
 }
В этом примере performReadOperation()метод помечен значком @Transactional(readOnly = true), указывающим, что транзакция доступна только для чтения и не должна изменять какие-либо данные.

Вы можете установить правила отката для транзакции: Атрибуты rollbackForи noRollbackForаннотации @Transactionalуказывают исключения, которые должны запускать откат или не запускать откат соответственно. Эти атрибуты позволяют точно контролировать поведение транзакций в случае определенных исключений.

@Transactional(rollbackFor = {SQLException. class , CustomException. class }) 
public  void  PerformTransactionalOperation () { 
    // Транзакционная операция 
    // ...
 }
В этом примере performTransactionalOperation()метод помечен значком @Transactional(rollbackFor = {SQLException.class, CustomException.class}), указывающим, что при возникновении SQLExceptionили CustomExceptionтранзакцию следует откатить. Имейте в виду, что если произойдет какое-либо другое исключение (например, NullPointerException, RuntimeException, и т. д.), транзакция не будет автоматически отменена.

Распространение транзакций: атрибут propagationаннотации @Transactionalуправляет тем, как транзакции распространяются между методами. Он определяет, должен ли метод присоединиться к существующей транзакции, создать новую транзакцию или работать без транзакции на основе контекста вызова. Вот некоторые часто используемые атрибуты распространения:

REQUIREDРаспространение:
@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodA () { 
    // Транзакционная операция 
    // ...
    
     methodB(); // Вызов метода B 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodB () { 
    // Транзакционная операция 
    // ...
 }
В этом примере methodA()аннотируется с помощью @Transactional(propagation = Propagation.REQUIRED). Когда methodA()вызывается, он запускает новую транзакцию. Когда он вызывает methodB(), транзакция, созданная в , methodA()распространяется на methodB(), что означает, что оба methodA()и methodB()участвуют в одной и той же транзакции.

2. REQUIRES_NEWРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodC () { 
    // Транзакционная операция 
    // ...
    
     methodD(); // Вызов метода D 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.REQUIRES_NEW) 
public  void  methodD () { 
    // Транзакционная операция 
    // ...
 }
В этом примере methodC()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodD()аннотируется @Transactional(propagation = Propagation.REQUIRES_NEW). При methodC()вызове он запускает транзакцию. Однако, когда он вызывает methodD(), новая транзакция запускается methodD()независимо, а транзакция methodC()приостанавливается. Оба метода работают в своих собственных транзакциях.

3. MANDATORYРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodE () { 
    // Транзакционная операция 
    // ...
    
     methodF(); // Вызов метода F 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.MANDATORY) 
public  void  methodF () { 
    // Транзакционная операция 
    // ...
 }
В этом примере methodE()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodF()аннотируется @Transactional(propagation = Propagation.MANDATORY). При methodE()вызове он запускает транзакцию. Однако при вызове methodF()ожидается, что транзакция уже активна. Если транзакции не существует, будет выдано исключение.

4. NESTEDРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodG () { 
    // Транзакционная операция 
    // ...
    
     methodH(); // Вызов методаH 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.NESTED) 
public  void  methodH () { 
    // Транзакционная операция 
    // ...
 }
В этом примере methodG()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodH()аннотируется @Transactional(propagation = Propagation.NESTED). При methodG()вызове он запускает транзакцию. При вызове methodH()внутри существующей транзакции создается новая вложенная транзакция. Если транзакции не существует, новая транзакция запускается для methodH().

5. SUPPORTSРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodI () { 
    // Транзакционная операция 
    // ...
    
     methodJ(); // Вызов метода J 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.SUPPORTS) 
public  void  methodJ () { 
    // Нетранзакционная операция 
    // ...
 }
В этом примере methodI()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodJ()аннотируется @Transactional(propagation = Propagation.SUPPORTS). При methodI()вызове он запускает транзакцию. При вызове methodJ()нетранзакционный метод выполняется без запуска новой транзакции.

6. NOT_SUPPORTEDРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodK () { 
    // Транзакционная операция 
    // ...
    
     methodL(); // Вызов метода L 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.NOT_SUPPORTED) 
public  void  methodL () { 
    // Нетранзакционная операция 
    // ...
 }
В этом примере methodK()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodL()аннотируется @Transactional(propagation = Propagation.NOT_SUPPORTED). При methodK()вызове он запускает транзакцию. Когда он вызывает methodL(), транзакция приостанавливается на время methodL(), что позволяет выполнить нетранзакционную операцию.

7. NEVERРаспространение:

@Transactional(propagation = Propagation.REQUIRED) 
public  void  methodM () { 
    // Транзакционная операция 
    // ...
    
     methodN(); // Вызов метода N 
    
    // Транзакционная операция 
    // ...
 } 
@Transactional(propagation = Propagation.NEVER) 
public  void  methodN () { 
    // Нетранзакционная операция 
    // ...
 }
В этом примере methodM()аннотируется @Transactional(propagation = Propagation.REQUIRED), а methodN()аннотируется @Transactional(propagation = Propagation.NEVER). При methodM()вызове он запускает транзакцию. Когда он вызывает methodN(), генерируется исключение, потому что methodN()его нельзя выполнять при наличии транзакции.

Эти примеры демонстрируют различное поведение распространения и то, как оно влияет на поведение транзакций, когда один метод вызывает другой. Понимая и выбирая соответствующее поведение распространения, вы можете контролировать, как транзакции распространяются и управляются в вашем приложении на основе конкретных требований каждого метода.

 https://nameishari.medium.com/you-dont-know-transactional-annotation-do-you-5210c84ac41f
