# 1. Service Registry
Шаблон предоставляет центральный репозиторий для обнаружения микрослужб по имени. Это шаблон архитектуры микрослужб, который позволяет службам обнаруживать другие микрослужбы и взаимодействовать друг с другом.

В этом шаблоне центральный реестр или каталог служб используется для хранения записей о доступных службах и их расположении. Микросервисы могут регистрироваться в реестре, а другие микросервисы могут искать в реестре местонахождение необходимых сервисов.

Например, предположим, что у нас есть большой веб-сайт электронной коммерции, который состоит из множества микросервисов , таких как служба заказа, служба оплаты, служба доставки и служба поддержки клиентов. Каждая из этих служб имеет собственный REST API, который другие службы могут использовать для связи с ней.

Чтобы упростить обнаружение этими службами друг друга, мы можем использовать шаблон реестра служб . Мы можем настроить реестр сервисов, таких как Consul или Eureka (предоставляется в облаке Spring), в котором хранится список всех доступных сервисов и их конечных точек.

Когда служба запускается, она может зарегистрироваться в реестре, указав свое имя и конечную точку.

Например, служба заказов может зарегистрировать себя как «служба заказов» с конечной точкой « http://order-service:8080 ». Другие службы, которым необходимо взаимодействовать со службой заказов, могут затем найти ее конечную точку в реестре, используя ее имя.

Например , платежная служба может найти конечную точку «служба заказа» в реестре, чтобы отправить платежную информацию службе заказов. Точно так же служба доставки может искать конечную точку «служба заказа» в реестре, чтобы получить информацию о доставке заказа.

Таким образом, каждую службу можно разрабатывать и развертывать независимо, без жесткого кодирования конечных точек других служб в ее коде. Шаблон реестра служб позволяет службам динамически находить друг друга, делая систему более гибкой и устойчивой к изменениям.

# 2.	Circuit Breaker (Схема автоматического выключателя)

Как следует из названия, шаблон прерывателя цепи предотвращает каскадный сбой, разрывая цепь, и позволяет приложениям продолжать работу при сбое одной или нескольких служб . Он используется для обработки ошибок, которые могут возникнуть в микросервисной архитектуре.

В этом шаблоне прерыватель цепи действует как сеть безопасности между клиентом и службой, защищая клиента от сбоев в службе. Прерыватель цепи отслеживает состояние службы и, если он обнаруживает, что служба дает сбой, он может разомкнуть цепь и предотвратить отправку дальнейших запросов в службу до тех пор, пока служба не будет восстановлена.

Например, предположим, что приложение микрослужбы использует ненадежную внешнюю службу, и приложению необходимо продолжать работу даже в случае сбоя внешней службы.

В этом сценарии можно использовать шаблон прерывателя цепи, чтобы определить, когда внешняя служба недоступна , и переключиться на альтернативную службу или резервную службу, пока внешняя служба снова не станет доступной.


В микросервисной архитектуре шаблон прерывателя цепи может быть реализован с помощью таких инструментов, как Hystrix от Netflix или Spring Cloud Circuit Breaker, которые позволяют управлять поведением прерывателя цепи и позволяют приложению контролируемым образом реагировать на сбои службы.

# 3.	API Gateway

Шаблон шлюза API — это еще один распространенный шаблон проектирования, используемый в архитектуре микросервисов, который включает шлюз API, выступающий в качестве точки входа для всех входящих запросов API. Он обеспечивает единую точку входа для всех микрослужб и действует как прокси-сервер между клиентами и микрослужбами, направляя запросы соответствующей службе.

Основная цель шлюза API — отделить клиентов от микросервисов, абстрагируя сложность системы за упрощенным и согласованным API. Это также означает, что вам не нужно находить и запоминать адреса более чем 100 API-интерфейсов REST Microservice.

Он также обеспечивает дополнительный уровень безопасности и управления, позволяя организациям контролировать и управлять доступом к своим службам, отслеживать производительность системы и применять политики для всех служб.

Вот пример того, как шаблон шлюза API работает в простой системе электронной коммерции:

Предположим, что система электронной коммерции имеет несколько микросервисов для выполнения различных функций, таких как управление заказами, каталог продуктов и аутентификация пользователей. У каждой микрослужбы есть собственная конечная точка API для обработки запросов. Однако клиенту, которым может быть веб-приложение или мобильное приложение, необходимо получить доступ ко всем этим микросервисам через единую точку входа.

Здесь в игру вступает шлюз API. Шлюз API действует как обратный прокси-сервер, который получает все входящие запросы от клиентов. Затем он направляет каждый запрос в соответствующую микрослужбу в зависимости от запрошенной конечной точки.

Например, шлюз API может направлять запросы к /orders конечной точке в микрослужбу управления заказами, а запросы к /products конечной точке — в микрослужбу каталога продуктов.


Шлюз API также может выполнять дополнительные функции, такие как преобразование запросов и ответов, ограничение скорости, аутентификация и авторизация, а также кэширование.

Он также может предоставить унифицированный API, который скрывает внутренние детали микросервисов и предоставляет клиентам более простой и согласованный интерфейс.

В целом шаблон шлюза API обеспечивает масштабируемый, гибкий и безопасный способ управления микросервисами в сложной системе, упрощая разработку, развертывание и обслуживание приложений на основе микросервисов.

# 4. Saga Pattern

Шаблон Saga предоставляет способ управления транзакциями, включающими несколько микросервисов. Он используется для обеспечения успешного завершения серии транзакций в нескольких службах, а если нет, для отката или отмены всех изменений, которые были сделаны до этого момента.

Шаблон Saga состоит из последовательности локальных транзакций, каждая из которых обновляет состояние отдельной службы , и соответствующего набора компенсирующих транзакций, которые используются для отмены эффектов исходных транзакций в случае сбоя.

Вот пример того, как шаблон Saga используется в приложении электронной коммерции на основе микросервиса:

Предположим, у вас есть два микросервиса, один из которых отвечает за обработку заказов, а другой — за доставку заказов .

Когда размещается новый заказ, служба обработки заказов отвечает за проверку заказа и обеспечение наличия товаров на складе, а служба доставки отвечает за упаковку заказа и отправку его покупателю.

Если служба обработки заказов определяет, что заказ действителен и все товары есть в наличии, она отправляет сообщение в службу доставки, чтобы инициировать процесс доставки. В этот момент в игру вступает шаблон Saga.

Служба доставки создаст новую транзакцию для упаковки и отправки заказа, и, если транзакция пройдет успешно, она пометит заказ как отправленный.

С другой стороны, если транзакция завершится неудачно (возможно, из-за проблемы с поставщиком услуг доставки), служба доставки инициирует компенсирующую транзакцию, чтобы отменить последствия исходной транзакции, такие как отмена отправки и пополнение запасов товаров.


Тем временем служба обработки заказов также использует шаблон Saga для управления собственной транзакцией . Если служба доставки сообщит об успешной отправке заказа, служба обработки заказов пометит заказ как выполненный.

Если служба доставки сообщает об ошибке, служба обработки заказов инициирует компенсационную транзакцию для отмены заказа и возврата всех уплаченных средств.

В целом, шаблон Saga обеспечивает способ управления сложными транзакциями в нескольких микросервисах таким образом, чтобы обеспечить согласованность и надежность. Если вам нужно выучить только один шаблон, вам лучше изучить шаблоны SAGA, поскольку они чрезвычайно полезны в приложениях Microservice.


# 5.	Event-Driven Architecture


